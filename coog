#!/bin/bash
# This script helps doing with Coog image.
# More informations: https://docs.docker.com/engine/reference/run/

get_session_args() {
        [ -z $COOG_SESSION_SUPERPWD ] && echo missing COOG_SESSION_SUPERPWD && return 1
        echo "-e COOG_SESSION_SUPERPWD=$COOG_SESSION_SUPERPWD"
}

get_db_args() {
        local args
        [ -z $COOG_DB_SYS ] && echo missing COOG_DB_SYS && return 1
        args="$args -e COOG_DB_SYS=$COOG_DB_SYS"
        [ -z $PG_HOST ] && echo missing PG_HOST && return 1
        args="$args -e COOG_DB_HOST=$PG_HOST"
        [ -z $PG_PORT ] && echo missing PG_PORT && return 1
        args="$args -e COOG_DB_PORT=$PG_PORT"
        [ -z $COOG_DB_USERNAME ] && echo missing COOG_DB_USERNAME && return 1
        args="$args -e COOG_DB_USER=$COOG_DB_USERNAME"
        [ -z $COOG_DB_PASSWORD ] && echo missing COOG_DB_PASSWORD && return 1
        args="$args -e COOG_DB_PASSWORD=$COOG_DB_PASSWORD"
        [ -z $COOG_DB_NAME ] && echo missing COOG_DB_NAME && return 1
        args="$args -e COOG_DB_NAME=$COOG_DB_NAME"
        [ -z $COOG_DB_LANG ] && echo missing COOG_DB_LANG && return 1
        args="$args -e COOG_DB_LANG=$COOG_DB_LANG"
        echo "$args"
}

get_cache_args() {
        local args
        [ ! -z $COOG_CACHE_SYS ] && args="$args -e COOG_CACHE_SYS=$COOG_CACHE_SYS"
        if [ ! -z $COOG_CACHE_SYS ] && [ $COOG_CACHE_SYS = redis ]
        then
                [ -z $REDIS_HOST ] && echo missing REDIS_HOST && return 1
                args="$args -e COOG_CACHE_HOST=$REDIS_HOST"
                [ -z $REDIS_PORT ] && echo missing REDIS_PORT && return 1
                args="$args -e COOG_CACHE_PORT=$REDIS_PORT"
                [ -z $COOG_CACHE_DB ] && echo missing COOG_CACHE_DB && return 1
                args="$args -e COOG_CACHE_DB=$COOG_CACHE_DB"
        fi
        [ ! -z $COOG_CACHE_MODEL ] && args="$args -e COOG_CACHE_MODEL=$COOG_CACHE_MODEL"
        [ ! -z $COOG_CACHE_RECORD ] && args="$args -e COOG_CACHE_RECORD=$COOG_CACHE_RECORD"
        [ ! -z $COOG_CACHE_FIELD ] && args="$args -e COOG_CACHE_FIELD=$COOG_CACHE_FIELD"
        [ ! -z $COOG_CACHE_COOG ] && args="$args -e COOG_CACHE_COOG=$COOG_CACHE_COOG"
        echo "$args"
}

get_async_args() {
        local args
        [ ! -z $COOG_ASYNC_SYS ] && args="$args -e COOG_ASYNC_SYS=$COOG_ASYNC_SYS"
        if [ ! -z $COOG_ASYNC_SYS ]
        then
                [ -z $REDIS_HOST ] && echo missing REDIS_HOST && return 1
                args="$args -e COOG_ASYNC_HOST=$REDIS_HOST"
                [ -z $REDIS_PORT ] && echo missing REDIS_PORT && return 1
                args="$args -e COOG_ASYNC_PORT=$REDIS_PORT"
                [ -z $COOG_ASYNC_DB ] && echo missing COOG_ASYNC_DB && return 1
                args="$args -e COOG_ASYNC_DB=$COOG_ASYNC_DB"
        fi
        echo "$args"
}

get_sentry_args() {
        local args
        if [ ! -z $COOG_SENTRY_PUB ] && [ ! -z $COOG_SENTRY_SEC ] && [ ! -z $COOG_SENTRY_PROJECT ]
        then
                [ -z $SENTRY_PROTOCOL ] && echo missing SENTRY_PROTOCOL && return 1
                args="$args -e COOG_SENTRY_PROTOCOL=$SENTRY_PROTOCOL"
                [ -z $SENTRY_HOST ] && echo missing SENTRY_HOST && return 1
                args="$args -e COOG_SENTRY_HOST=$SENTRY_HOST"
                [ -z $SENTRY_PORT ] && echo missing SENTRY_PORT && return 1
                args="$args -e COOG_SENTRY_PORT=$SENTRY_PORT"
                [ -z $COOG_SENTRY_PUB ] && echo missing COOG_SENTRY_PUB && return 1
                args="$args -e COOG_SENTRY_PUB=$COOG_SENTRY_PUB"
                [ -z $COOG_SENTRY_SEC ] && echo missing COOG_SENTRY_SEC && return 1
                args="$args -e COOG_SENTRY_SEC=$COOG_SENTRY_SEC"
                [ -z $COOG_SENTRY_PROJECT ] && echo missing COOG_SENTRY_PROJECT && return 1
                args="$args -e COOG_SENTRY_PROJECT=$COOG_SENTRY_PROJECT"
        fi
        echo "$args"
}

_run() {
        local mode; mode=$1; shift
        local args
        if [ $mode = i ]
        then
                args="-ti --rm"
        elif [ $mode = d ]
        then
                local name; name=$1; shift
                args="-d --name=$name"
        else
                echo "unexpected mode" && return 1
        fi
        args="$args -v $COOG_VOLUME:/opt/coog/data"
        args="$args "`get_session_args`
        args="$args "`get_db_args`
        args="$args "`get_cache_args`
        args="$args "`get_async_args`
        args="$args "`get_sentry_args`
        docker run \
                $args \
                $COOG_IMAGE \
                $*
}

version() {
        _run i version $*
}

env() {
        _run i env $*
}

config() {
        _run i config $*
}

upgrade() {
        _run i app -v -d $COOG_DB_NAME -u ir res
}

worker() {
        [ -z $1 ] && echo no worker id && return 1
        local name; name=$COOG_CONTAINER-$1
        shift
        _run d $name app $*
}

workers() {
        local id; id=1
        while [ $id -le $WORKERS ]
        do
                worker $id $*
                id=`echo "$id+1" | bc`
        done
}

batch() {
        _run i batch $*
}

usage() {
        echo
        echo Possible commands
        echo
        echo "  version : get image version (git trees)"
        echo "  env     : get container env vars"
        echo "  config  : get container coog configuration"
        echo "  upgrade : upgrade coog database (according to new app version)"
        echo "  worker  : start worker container (needs a worker id.)"
        echo "  workers : start workers"
        echo "  batch   : launch batch execution"
        echo
}

main() {
        local script_path; script_path=`readlink -f $0`
        local script_dir; script_dir=`dirname $script_path`
        source $script_dir/.env
        #
        [ -z $1 ] && usage && return 1
        local cmd; cmd=$1; shift
        #
        [ $cmd = version ] && { version $*; return $?; }
        [ $cmd = env ] && { env $*; return $?; }
        [ $cmd = config ] && { config $*; return $?; }
        [ $cmd = upgrade ] && { upgrade $*; return $?; }
        [ $cmd = worker ] && { worker $*; return $?; }
        [ $cmd = workers ] && { workers $*; return $?; }
        [ $cmd = batch ] && { batch $*; return $?; }
        usage && return 1
}

main $*
